pragma solidity ^0.8.7;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "contracts/libraries/SafeMath.sol";
import "@openzeppelin/contracts/access/Ownable.sol";


contract StakingToken is ERC20, Ownable {
   using SafeMath for uint256;
    uint256 tokenPrice = 1;
    uint256 nextDueDate;
    uint256 lastWithdrawal;
    bool isEligible;
    event Bought(uint256 amount);
   address[] internal stakeholders;
   mapping(address => uint256) internal expiryOf;
   mapping(address => uint256) internal stakes;
   mapping(address => uint256) internal rewards;
  mapping(address => uint256) internal _balanceOf;

   constructor(address payable _owner, uint256 _supply)
       ERC20("BlueSurgeToken", "BST") payable {
       _mint(_owner, _supply);
   }

   function isStakeholder(address _address)
       public
       view
       returns(bool, uint256)
   {
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           if (_address == stakeholders[s]) return (true, s);
       }
       return (false, 0);
   }

   /**
    * @notice A method to add a stakeholder.
    * @param _stakeholder The stakeholder to add.
    */
   function addStakeholder(address _stakeholder)
       public
   {
       (bool _isStakeholder, ) = isStakeholder(_stakeholder);
       if(!_isStakeholder) stakeholders.push(_stakeholder);
   }

   /**
    * @notice A method to remove a stakeholder.
    * @param _stakeholder The stakeholder to remove.
    */
   function removeStakeholder(address _stakeholder)
       public
   {
       (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);
       if(_isStakeholder){
           stakeholders[s] = stakeholders[stakeholders.length - 1];
           stakeholders.pop();
       }
   }

   function modifyBuyTokenPrice( uint256 _newPrice) public onlyOwner {
       tokenPrice = _newPrice;
   }

   function buyToken(address _reciever, uint256 _value) public payable returns (bool success) {
        uint256 _fee = _value/tokenPrice;
        require(balanceOf(msg.sender) >= _fee);
        _transfer(msg.sender, _reciever, _value);
        // transferFrom(_reciever, msg.sender, _fee);
        return true;
    }

    function stakeOf(address _stakeholder)
       public
       view
       returns(uint256)
   {
       return stakes[_stakeholder];
   }

   /**
    * @notice A method to the aggregated stakes from all stakeholders.
    * @return uint256 The aggregated stakes from all stakeholders.
    */
   function totalStakes()
       public
       view
       returns(uint256)
   {
       uint256 _totalStakes = 0;
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           _totalStakes = _totalStakes.add(stakes[stakeholders[s]]);
       }
       return _totalStakes;
   }

    function createStake(uint256 _stake)
       public
   {
    //    lastWithdrawal = block.timestamp;
       _burn(msg.sender, _stake);
       if(stakes[msg.sender] == 0) addStakeholder(msg.sender);
       stakes[msg.sender] = stakes[msg.sender].add(_stake);
   }

   /**
    * @notice A method for a stakeholder to remove a stake.
    * @param _stake The size of the stake to be removed.
    */
   function removeStake(uint256 _stake)
       public
   {
       stakes[msg.sender] = stakes[msg.sender].sub(_stake);
       if(stakes[msg.sender] == 0) removeStakeholder(msg.sender);
       _mint(msg.sender, _stake);
   }

   function rewardOf(address _stakeholder)
       public
       view
       returns(uint256)
   {
       return rewards[_stakeholder];
   }

   function totalRewards()
       public
       view
       returns(uint256)
   {
       uint256 _totalRewards = 0;
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           _totalRewards = _totalRewards.add(rewards[stakeholders[s]]);
       }
       return _totalRewards;
   }

   function calculateReward(address _stakeholder)
       public
       view
       returns(uint256)
   {
       return stakes[_stakeholder] / 100;
   }

 function distributeRewards()
       public
       onlyOwner
   {
       for (uint256 s = 0; s < stakeholders.length; s += 1){
           address stakeholder = stakeholders[s];
           uint256 reward = calculateReward(stakeholder);
           rewards[stakeholder] = rewards[stakeholder].add(reward);
       }
   }

   /**
    * @notice A method to allow a stakeholder to withdraw his rewards.
    */
   function withdrawReward()
       public
   {
       lastWithdrawal = block.timestamp - 7 days;
       nextDueDate = lastWithdrawal + 7 days;
    //    require(block.timestamp >= nextDueDate,  "You are not eligible to claim rewards yet!");
       uint256 reward = rewards[msg.sender];
            rewards[msg.sender] = 0;
            _mint(msg.sender, reward);
            
   }

     
   
}
